/**********************************************************************
 * 
 * generic tuple ordering - v0.1
 * 
 * author: robbert van dalen
 *
**********************************************************************/

Module "ordering"
Uses
  "Avail"
Names
  "compare_with_",
  "_>_",
  "_<_",
  "_≥_",
  "_≤_",
  "sort_",
  "test ordering"
Entries
  "test ordering"
Body

/* aliases */
ordering ::= [-1..1];
ttype ::= tuple's type;

/* compare anything with anything, given certain semantic restrictions */
Abstract method "compare_with_" is [any,any] → ordering;

/* compare two numbers */
Method "compare_with_" is [ n1: number, n2: number | 
  if n1 > n2 then [1] else if [n1 < n2] then [-1] else [0]
] : ordering;

/* compare two characters */
Method "compare_with_" is [ c1: character, c2: character | 
  cp1 ::= c1's code point;
  cp2 ::= c2's code point;
  if cp1 > cp2 then [1] else if [cp1 < cp2] then [-1] else [0]
] : ordering;

/* compare two tuples *without* semantic restrictions */
Method "compare tuple_with_" is
[
  s1 : tuple,
  s2 : tuple
|
  $body : ordering;

  From 1 to |s1| min |s2| do [ index : natural number |
    cp1 ::= s1[index];
    cp2 ::= s2[index];
    cmp ::= compare cp1 with cp2;

    If cmp ≠ 0 then [Exit body with cmp];
  ];

  compare |s1| with |s2|
] : ordering;

/* compare two tuples *with* semantic restrictions */
Method "compare_with_" is
[
  t1 : tuple,
  t2 : tuple
|
  compare tuple t1 with t2
] : ordering;

/* any types are *not* comparable */
Method "_is comparable with_" is [ t1: any's type, t2: any's type |
  false 
] : boolean;

/* number types are comparable */
Method "_is comparable with_" is [ t1: number's type, t2: number's type |
  true 
] : boolean;

/* character types are comparable */
Method "_is comparable with_" is [ t1: character's type, t2: character's type |
  true 
] : boolean;

/* tuples types are comparable, but only when every tuple element is pairwise 
 comparable */
Method "_is comparable with_" is [ 
  t1: ttype, t2: ttype
|
  $body : boolean;
    
  t1l ::= t1's leading types ++ <t1's default type>;
  t2l ::= t2's leading types ++ <t2's default type>;
  
  From 1 to |t1l| min |t2l| do [ index : natural number |
    If (t1l[index] is comparable with t2l[index]) = false
    then [Exit body with false];
  ];

  true
] : boolean;

/* check whether two tuples are comparable. otherwise throw a parse rejection */
Method "check_is comparable with_" is 
[
  t1 : any's type,
  t2 : any's type
|    
  Unless t1 is comparable with t2 then
  [
    Reject parse, expected:
    format "“①” isn't is comparable with to “②”"
    with t1, t2
  ];

  ⊤
];

Semantic restriction "compare_with_" is
[
  t1 : any's type,
  t2 : any's type
|    
  check t1 is comparable with t2
];

/* compare tuples using standard symbols */
Method "_>_" is [ t1 : tuple, t2 : tuple | compare tuple t1 with t2 > 0] : boolean;
Method "_<_" is [ t1 : tuple, t2 : tuple | compare tuple t1 with t2 < 0] : boolean;
Method "_≥_" is [ t1 : tuple, t2 : tuple | compare tuple t1 with t2 ≥ 0] : boolean;
Method "_≤_" is [ t1 : tuple, t2 : tuple | compare tuple t1 with t2 ≤ 0] : boolean;

Semantic restriction "_>_" is [ t1 : ttype, t2 : ttype | check t1 is comparable with t2 ];
Semantic restriction "_<_" is [ t1 : ttype, t2 : ttype | check t1 is comparable with t2 ];
Semantic restriction "_≥_" is [ t1 : ttype, t2 : ttype | check t1 is comparable with t2 ];
Semantic restriction "_≤_" is [ t1 : ttype, t2 : ttype | check t1 is comparable with t2 ];

/* check wether all 'list' entries are comparable */
Method "_'s⁇entries are comparable" is [ lt: <tuple…|0..∞>'s type |
  $body : boolean;
  
  leading ::= lt's leading types;
  default ::= lt's default type;

  From 1 to |leading| do [ index : natural number |
    cmp ::= leading[index] is comparable with default;
    If cmp = false then [Exit body with false];
  ];

  default is comparable with default
] : boolean;

/* sort tuples, by comparing tuples */
Method "sort_" is [ list: <tuple…|0..∞> |
  merge sort list with [ t1: tuple, t2: tuple | compare tuple t1 with t2 ≤ 0 ]
] : <tuple…|0..∞>;

tty ::= <integer…|1>; 

Semantic restriction "sort_" is [ lt: <tuple…|0..∞>'s type |
  Unless lt's entries are comparable then
  [
    Reject parse, expected:
    format "“①”'s entries aren't comparable"
    with lt
  ];

  leading ::= lt's leading types;  
  uniontype : any's type := lt's default type;
      
  From 1 to |leading| do [ index : natural number |
    uniontype := leading[index] ∪ uniontype;
  ]; 
     
  <uniontype…|0..∞>
];


Public method "test ordering" is 
[  
  t1 ::= <1>;
  t2 ::= <4>;
  t3 ::= <5>;
    
  t5 ::= <t1,t2,t3>;
  t6 ::= sort t5;
  t7 ::= t6 ++ <<2,"A">>; 
  
  t8 ::= sort t7;
  
  t8
];
