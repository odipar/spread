/**********************************************************************
 * 
 * an experimental treap implementation in avail - v0.2
 * 
 * depends on revision avail@bfed27a and later
 *
 * author: Robbert van Dalen
 *
**********************************************************************/

Module "Treap"
Uses
	"Avail"
Names
	"_treap",
	"_∪_",
	"_∩_",
	"_Δ_",
	"test treap"
Entries
 "test treap"
Body

"tleft" is a new field atom;
"tvalue" is a new field atom;
"tright" is a new field atom;
"root" is a new field atom;
"ordering" is a new field atom;

/**
 * a treap is a tree and a heap, roughly balanced using deterministic value
 * hashes. the basic data structure is untyped and imposes no order.
 */
Explicit class "treap" extends object;

/* an abstract ordering */
orderingType ::= [⊥,⊥]→number;

/* a typed treap imposes an ordering over an untyped treap */
Explicit class "typed treap" extends object 
  with fields
    ordering : orderingType,
    root : treap;
    
Explicit class "empty treap" extends treap;
Explicit class "full treap" extends treap with fields tvalue : any;
Explicit class "leaf treap" extends full treap;
Explicit class "leftish treap" extends full treap
  with fields                      
    tleft : treap;
Explicit class "rightish treap" extends full treap 
  with fields 
    tright : treap;
Explicit class "bin treap" extends full treap 
  with fields
    tleft : treap,
    tright : treap;

/* note that all non-public methods are in postfix to disambiguate.
 * and also because the author likes postfix (exactly because of non-ambiguity)
 */
Abstract method "_'s⁇left" is [treap]→treap;
Abstract method "_'s⁇value" is [treap]→any;
Abstract method "_'s⁇prio" is [treap]→integer;
Abstract method "_'s⁇right" is [treap]→treap;
Abstract method "_'s⁇depth" is [treap]→integer;
Abstract method "_'s⁇last" is [treap]→any;
Abstract method "_'s⁇first" is [treap]→any;
Abstract method "___create" is [treap,any,treap]→treap;
Forward  method "__join" is [treap,treap]→treap;

empty ::= an empty treap;
incorrect ::= an incorrect-argument-type exception;

/* exceptions should never be thrown because of the treap's implicit
 * invariants.
 */
Method "_'s⁇left" is [ t : empty treap | Raise incorrect ];
Method "_'s⁇value" is [ t : empty treap | Raise incorrect ];
Method "_'s⁇right" is [ t : empty treap | Raise incorrect ];
Method "_'s⁇prio" is [ t : empty treap | 0 ];
Method "_'s⁇depth" is [ t : empty treap | 0 ];
Method "_'s⁇first" is [ t : empty treap | Raise incorrect ];
Method "_'s⁇last" is [ t : empty treap | Raise incorrect ];
         
Method "_'s⁇left" is [ t : leaf treap | empty ];
Method "_'s⁇right" is [ t : leaf treap | empty ];
Method "_'s⁇depth" is [ t : leaf treap | 1 ];
Method "_'s⁇first" is [ t : leaf treap | t's value ];
Method "_'s⁇last" is [ t : leaf treap | t's value ];

Method "_'s⁇left" is [ t : leftish treap | t's tleft ];
Method "_'s⁇right" is [ t : leftish treap | empty ];
Method "_'s⁇depth" is [ t : leftish treap | 1 + t's left's depth ];
Method "_'s⁇first" is [ t : leftish treap | t's left's first ];
Method "_'s⁇last" is [ t : leftish treap | t's value ];

Method "_'s⁇left" is [ t : rightish treap | empty ];
Method "_'s⁇right" is [ t : rightish treap | t's tright ];
Method "_'s⁇depth" is [ t : rightish treap | 1 + t's right's depth ];
Method "_'s⁇first" is [ t : rightish treap | t's value ];
Method "_'s⁇last" is [ t : rightish treap | t's right's last ];

Method "_'s⁇left" is [ t : bin treap | t's tleft ] ;
Method "_'s⁇right" is [ t : bin treap | t's tright ];
Method "_'s⁇depth" is [ t : bin treap | t's left's depth max t's right's depth];
Method "_'s⁇first" is [ t : bin treap | t's left's first ];
Method "_'s⁇last" is [ t : bin treap | t's right's last ];

/* a full treap always has a value */
Method "_'s⁇value" is [ t : full treap | t's tvalue ];

/* the full treap's priority is drawn from the value's deterministic hash.
 * using determistic hashes, a treap collapses into a unique representation,
 * irrespective of insertion order.
 */

Method "_'s⁇prio" is [ t : full treap | t's tvalue's hash ];

Method "___create" is 
[
  left: empty treap,
  value: any,
  right: empty treap 
|                                                    
  a leaf treap with tvalue ::= value
];

Method "___create" is 
[
  left: full treap,
  value: any,
  right: empty treap 
| 
  a leftish treap with tleft ::= left, tvalue ::= value
];

Method "___create" is 
[
  left: empty treap,
  value: any,
  right: full treap 
| 
  a rightish treap with tvalue ::= value, tright ::= right
];

Method "___create" is 
[
  left: full treap,
  value: any,
  right: full treap 
| 
  a bin treap with tleft ::= left, tvalue ::= value, tright ::= right
];

/* joins two treaps t1 and t2. 
 * every element in t1 should be smaller than every element in t2
 */
Method "__join" is [ t1 : empty treap, t2: empty treap | t2 ];
Method "__join" is [ t1 : empty treap, t2: treap | t2 ];
Method "__join" is [ t1 : treap, t2: empty treap | t1 ];
Method "__join" is 
[ 
  t1 : treap,
  t2 : treap
|  
  if t1's prio > t2's prio then 
  [
    t1's left t1's value t1's right t2 join create
  ]
  else
  [
    t1 t2's left join t2's value t2's right create
  ]  
];

Method "_as a treap" is 
[ 
  v : any 
| 
  a leaf treap with tvalue ::= v 
];


/* splits a treap into three parts, given a value and an ordering */
Abstract method "___split" is [treap,any,orderingType]→<treap…|3>;

Method "___split" is
[
  treap: empty treap,
  x: any,
  ordering: orderingType
|
  <empty,empty,empty>
];

Method "___split" is
[
  treap: full treap,
  x: any,
  ordering: orderingType
|
  compare ::= ordering(treap's value,x);
  
  if compare > 0 then 
  [
    split ::= treap's left x ordering split;
    
    left ::= split[1];
    middle ::= split[2];
    right ::= split[3] treap's value as a treap join treap's right join;
    
    <left,middle,right>
  ]
  else
  [
    if compare < 0 then
    [
      split ::= treap's right x ordering split;
      
      left ::= treap's left treap's value as a treap join split[1] join;
      middle ::= split[2];
      right ::= split[3];
      
      <left,middle,right>
    ]
    else
    [
      <treap's left,treap's value as a treap,treap's right>
    ]
  ]
] : <treap…|3>;


/* splits a typed treap into three parts, given a value and an ordering */
Method "__split" is 
[
  treap : typed treap,
  x : any
|
  split ::= treap's root x treap's ordering split;
  
  left ::= a typed treap with ordering ::= treap's ordering, root ::= split[1];
  mid ::= a typed treap with ordering ::= treap's ordering, root ::= split[1];
  right ::= a typed treap with ordering ::= treap's ordering, root ::= split[2];
  
  <left,mid,right>
] : <typed treap…|3>;


/* inserts a value into a treap */
Abstract method "___insert" is [treap,any,orderingType]→treap;

Method "___insert" is 
[
  t : empty treap,
  x : any,
  ord : orderingType
|
  x as a treap
];

Method "___insert" is
[
  t : full treap,
  x : any,
  ord : orderingType
|
  if ord(t's last,x) < 0 then [ t x as a treap join ] /* fast concat */
  else
  [
    if ord(t's first,x) > 0 then [ x as a treap t join ] /* fast prepend */
    else /* slow insert */
    [
      split ::= t x ord split;  
      split[1] x as a treap join split[3] join
    ]
  ]
] : treap;

Explicit class "set operation" extends object;
Explicit class "union" extends set operation;
Explicit class "intersect" extends set operation;
Explicit class "difference" extends set operation;

_union ::= a union;
_intersect ::= an intersect;
_difference ::= a difference;

Abstract method "___equal" is [treap,treap,set operation]→treap;
Abstract method "___disjoint" is [treap,treap,set operation]→treap;

Method "___equal" is [ t1 : treap, t2 : treap, o : union | t1 ];
Method "___disjoint" is [ t1 : treap, t2 : treap, o : union | t1 t2 join ];

Method "___equal" is [ t1 : treap, t2 : treap, o : intersect | t1 ];
Method "___disjoint" is [ t1 : treap, t2 : treap, o : intersect | empty ];

Method "___equal" is [ t1 : treap, t2 : treap, o : difference | empty ];
Method "___disjoint" is [ t1 : treap, t2 : treap, o : difference | t1 t2 join ];

/* combines two treaps into a new treap, given an ordering and set operation */
Abstract method "____combine" is [treap,treap,orderingType,set operation]→treap; 

Method "____combine" is 
[ 
  t1 : empty treap,
  t2 : empty treap,
  ord : orderingType,
  operation : set operation
| 
  t1 
];

Method "____combine" is 
[ 
  t1 : empty treap,
  t2 : full treap,
  ord : orderingType,
  operation : set operation
| 
  t1 t2 operation disjoint
];

Method "____combine" is
[ 
  t1 : full treap,
  t2 : empty treap,
  ord : orderingType,
  operation : set operation
| 
  t1 t2 operation disjoint 
];


Method "____combine" is
[
  t1 : full treap,
  t2 : full treap,
  ord : orderingType,
  operation : set operation
|
  if t1 = t2 then [ t1 t2 operation equal ]
  else
  [
    if ord(t1's last,t2's first) < 0 then [t1 t2 operation disjoint]
    else
    [
      if ord(t1's first,t2's last) > 0 then [t2 t1 operation disjoint]
      else
      [
        value ::= t2's value;
        split ::= t1 value ord split;
        
        left ::= split[1] t2's left ord operation combine;
        middle ::= split[2] value as a treap ord operation combine;
        right ::= split[3] t2's right ord operation combine;

        left middle join right join
      ]
    ]
  ]
] : treap;

/* the public - typed - element addition method, infix style */
Method "_+_" is 
[
  t : typed treap,
  x : any
|
  ord ::= t's ordering;
  newroot ::= t's root x ord insert;
  a typed treap with ordering ::= ord, root ::= newroot
] : typed treap;

Semantic restriction "_+_" is
[
  treapType : typed treap's type,
  xType : any's type
|
  ordType ::= treapType's ordering;
    
  Unless xType ⊆ ordType's parameters' type[1] then
  [
    Reject parse, expected:
    format "element type ⊆ “①” to be a subtype of “②”'s parameters"
    with xType, ordType
  ];

  treapType
];

Method "___combine" is
[
  t1 : typed treap,
  t2 : typed treap,
  op : set operation
|
  ord ::= t1's ordering;
  newroot ::= t1's root t2's root ord op combine;
  a typed treap with ordering ::= ord, root ::= newroot
] : typed treap;

Method "__combine types" is
[
  treapType1 : typed treap's type,
  treapType2 : typed treap's type
|
  ordType1 ::= treapType1's ordering;
  ordType2 ::= treapType2's ordering;

  /* TODO [RVD]: allow orderings types to be subtypes of each other? */
  Unless ordType1 = ordType2 then
  [
    Reject parse, expected:
    format "ordering type “①” has to be equal to ordering type “②”"
    with ordType1, ordType2
  ];
  
  treapType1
] : typed treap's type;

Public method "_∪_" is
[
  t1 : typed treap,
  t2 : typed treap
|
  t1 t2 _union combine
] : typed treap;

Semantic restriction "_∪_" is
[
  treapType1 : typed treap's type,
  treapType2 : typed treap's type
|
  treapType1 treapType2 combine types
];

Public method "_∩_" is
[
  t1 : typed treap,
  t2 : typed treap
|
  t1 t2 _intersect combine
] : typed treap;

Semantic restriction "_∩_" is
[
  treapType1 : typed treap's type,
  treapType2 : typed treap's type
|
  treapType1 treapType2 combine types
];

Public method "_Δ_" is
[
  t1 : typed treap,
  t2 : typed treap
|
  t1 t2 _difference combine
] : typed treap;

Semantic restriction "_Δ_" is
[
  treapType1 : typed treap's type,
  treapType2 : typed treap's type
|
  treapType1 treapType2 combine types
];

/* pretty printing */
Abstract method "_show" is [treap]→string;

Method "_show" is [ t : empty treap | "" ];
Method "_show" is [ t : leaf treap | “t's value” ];
Method "_show" is [ t : leftish treap | t's left show ++ ", " ++ “t's value” ];
Method "_show" is [ t : rightish treap | “t's value” ++ ", " ++ t's right show ];
Method "_show" is 
[ 
  t : bin treap
| 
  t's left show ++ ", " ++ “t's value” ++ ", " ++ t's right show
];
     
Method "“_”" is
[
 t : treap
|
  "【" ++ t show ++ "】"
];

Method "“_”" is
[
 t : typed treap
|
  "【" ++ t's root show ++ "】"
];

Method "_treap" is 
[ 
  ord : orderingType 
| 
  a typed treap with ordering ::= ord, root ::= empty
] : typed treap;

Semantic restriction "_treap" is 
[
  ordMetaType : orderingType's type
|
  ordPars  ::= ordMetaType's parameters' type;
  arg1Type ::= ordPars[1];
  arg2Type ::= ordPars[2];
  
  Unless arg1Type = arg2Type then
  [
    Reject parse, expected:
    format "ordering parameter types “①” and “②” have to be equal"
    with arg1Type, arg2Type
  ];
  extend typed treap with ordering : ordMetaType
] : typed treap's type;

Public method "test treap" is 
[
  t ::= [ x : [0..8], y : [0..8] | x - y ] treap;
  
  t2 ::= t + 1 + 3 + 5 + 0 + 8 + 4;
  t3 ::= t + 8 + 3 + 5 + 4 + 1 + 0;
  t4 ::= t + 1 + 3 + 5 + 6 + 8;
  t5 ::= t + 2 + 3 + 4 + 7 + 8;
  t6 ::= t4 ∪ t5;
  t7 ::= t4 ∩ t5;
  t8 ::= t4 Δ t5;
  <t,t2,t3,t2 = t3,t3 = t4,t4,t5,t6,t7,t8>
];



