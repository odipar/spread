/**********************************************************************
 * 
 * an experimental treap implementation in avail - v0.1
 *
 * author: Robbert van Dalen
 *
**********************************************************************/

Module "Treap"
Uses
	"Avail"
Names
	"_treap",
	"__split",
	"test treap"
Entries
 "test treap"
Body

"tleft" is a new field atom;
"tvalue" is a new field atom;
"tright" is a new field atom;
"root" is a new field atom;
"ordering" is a new field atom;

/**
 * a treap is a tree and a heap, roughly balanced using deterministic value
 * hashes. the basic data structure is untyped and imposes no order.
 *
 * @type "treap"
 */
Explicit class "treap" extends object;

/* may be there is a better way to pass abstract orderings, but this will do */
orderingType ::= [⊥,⊥]→number;

/**
 * A typed treap imposes an ordering over an untyped treap
 *
 * @type "treap"
 */
Explicit class "typed treap" extends object 
  with fields
    ordering : orderingType,
    root : treap;
    
Explicit class "empty treap" extends treap;
Explicit class "full treap" extends treap with fields tvalue : any;
Explicit class "leaf treap" extends full treap;
Explicit class "leftish treap" extends full treap
  with fields                      
    tleft : treap;
Explicit class "rightish treap" extends full treap 
  with fields 
    tright : treap;
Explicit class "bin treap" extends full treap 
  with fields
    tleft : treap,
    tright : treap;

/* 
 * note that all non-public methods are in postfix to disambiguate.
 * and also because the author likes postfix (exactly because of non-ambiguity)
 */
Abstract method "_'s⁇left" is [treap]→treap;
Abstract method "_'s⁇value" is [treap]→any;
Abstract method "_'s⁇prio" is [treap]→integer;
Abstract method "_'s⁇right" is [treap]→treap;
Abstract method "_'s⁇depth" is [treap]→integer;
Abstract method "_'s⁇last" is [treap]→any;
Abstract method "_'s⁇first" is [treap]→any;
Abstract method "___create" is [treap,any,treap]→treap;
Forward  method "__join" is [treap,treap]→treap;
Forward  method "_'s⁇rehash" is [any]→integer;

empty ::= an empty treap;
incorrect ::= an incorrect-argument-type exception;

/* note that exceptions should never be thrown because of the treap's implicit
 * invariants.
 */
Method "_'s⁇left" is [ t : empty treap | Raise incorrect ];
Method "_'s⁇value" is [ t : empty treap | Raise incorrect ];
Method "_'s⁇right" is [ t : empty treap | Raise incorrect ];
Method "_'s⁇prio" is [ t : empty treap | 0 ];
Method "_'s⁇depth" is [ t : empty treap | 0 ];
Method "_'s⁇first" is [ t : empty treap | Raise incorrect ];
Method "_'s⁇last" is [ t : empty treap | Raise incorrect ];
         
Method "_'s⁇left" is [ t : leaf treap | empty ];
Method "_'s⁇right" is [ t : leaf treap | empty ];
Method "_'s⁇depth" is [ t : leaf treap | 1 ];
Method "_'s⁇first" is [ t : leaf treap | t's value ];
Method "_'s⁇last" is [ t : leaf treap | t's value ];

Method "_'s⁇left" is [ t : leftish treap | t's tleft ];
Method "_'s⁇right" is [ t : leftish treap | empty ];
Method "_'s⁇depth" is [ t : leftish treap | 1 + t's left's depth ];
Method "_'s⁇first" is [ t : leftish treap | t's left's first ];
Method "_'s⁇last" is [ t : leftish treap | t's value ];

Method "_'s⁇left" is [ t : rightish treap | empty ];
Method "_'s⁇right" is [ t : rightish treap | t's tright ];
Method "_'s⁇depth" is [ t : rightish treap | 1 + t's right's depth ];
Method "_'s⁇first" is [ t : rightish treap | t's value ];
Method "_'s⁇last" is [ t : rightish treap | t's right's last ];

Method "_'s⁇left" is [ t : bin treap | t's tleft ] ;
Method "_'s⁇right" is [ t : bin treap | t's tright ];
Method "_'s⁇depth" is [ t : bin treap | t's left's depth max t's right's depth];
Method "_'s⁇first" is [ t : bin treap | t's left's last ];
Method "_'s⁇last" is [ t : bin treap | t's right's last ];

/* the default rehash just takes the hash */
Method "_'s⁇rehash" is [ t : any | t's hash ];

/* but we have to rehash numbers because they are currently not well 
 * distributed, causing inbalanced treaps.
 */
Method "_'s⁇rehash" is
[ 
  t : number
| 
  hash ::= t's hash;
  /* make a feeble attempt to distribute a numbers hash */
  rehash ::= -2147483648 + ((hash × (hash + 31)) mod 4294967298);
  rehash
];

/* a full treap always has a value */
Method "_'s⁇value" is [ t : full treap | t's tvalue ];

/* the full treap's priority is drawn from the value's deterministic (re)hash.
 * using determistic hashes, a treap collapses into a unique representation,
 * irrespective of insertion order.
 */

Method "_'s⁇prio" is [ t : full treap | t's tvalue's rehash ];

Method "___create" is 
[
  left: empty treap,
  value: any,
  right: empty treap 
|                                                    
  a leaf treap with tvalue ::= value
];

Method "___create" is 
[
  left: full treap,
  value: any,
  right: empty treap 
| 
  a leftish treap with tleft ::= left, tvalue ::= value
];

Method "___create" is 
[
  left: empty treap,
  value: any,
  right: full treap 
| 
  a rightish treap with tvalue ::= value, tright ::= right
];

Method "___create" is 
[
  left: full treap,
  value: any,
  right: full treap 
| 
  a bin treap with tleft ::= left, tvalue ::= value, tright ::= right
];

/* joins two treaps a and b. 
 * all elements in a should be smaller than all elements in b
 */
Method "__join" is [ t1 : empty treap, t2: treap | t2 ];
Method "__join" is [ t1 : treap, t2: empty treap | t1 ];
Method "__join" is 
[ 
  t1 : treap,
  t2 : treap
|  
  if t1's prio > t2's prio then 
  [
    t1's left t1's value t1's right t2 join create
  ]
  else
  [
    t1 t2's left join t2's value t2's right create
  ]  
];

Method "_as a treap" is 
[ 
  v : any 
| 
  a leaf treap with tvalue ::= v 
];

/* splits a treap between a value, given an ordering */
Abstract method "___split" is [treap,any,orderingType]→<treap…|2>;
    
Method "___split" is
[
  treap: empty treap,
  x: any,
  ordering: orderingType
|
  <empty,empty>
];

Method "___split" is
[
  treap: full treap,
  x: any,
  ordering: orderingType
|
  compare ::= ordering(treap's value,x);
  
  if compare > 0 then 
  [
    split ::= treap's left x ordering split;
    left ::= split[1];
    right ::= split[2] treap's value as a treap join treap's right join;
    <left,right>
  ]
  else
  [
    if compare < 0 then
    [
      split ::= treap's right x ordering split;
      left ::= treap's left treap's value as a treap join split[1] join;
      right ::= split[2];
      <left,right>
    ]
    else
    [
      <treap's left,treap's right>
    ]
  ]
];

/* splits a typed treap between a value, given an ordering */
Method "__split" is 
[
  treap : typed treap,
  x : any
|
  split ::= treap's root x treap's ordering split;  
  left ::= a typed treap with ordering ::= treap's ordering, root ::= split[1];
  right ::= a typed treap with ordering ::= treap's ordering, root ::= split[2];
  <left,right>
] : <typed treap…|2>;


/* inserts a value into a treap */
Abstract method "___insert" is [treap,any,orderingType]→treap;

Method "___insert" is 
[
  t : empty treap,
  x : any,
  ord : orderingType
|
  x as a treap
];

Method "___insert" is
[
  t : full treap,
  x : any,
  ord : orderingType
|
  if ord(t's last,x) < 0 then [ t x as a treap join ] /* fast concat */
  else
  [
    if ord(t's first,x) > 0 then [ x as a treap t join ] /* fast prepend */
    else /* slow insert */
    [
      split ::= t x ord split;  
      split[1] x as a treap join split[2] join
    ]
  ]
] : treap;

/* the public - typed - element addition method, infix style */
Method "_+_" is 
[
  t : typed treap,
  x : any
|
  ord ::= t's ordering;
  newroot ::= t's root x ord insert;
  a typed treap with ordering ::= ord, root ::= newroot
] : typed treap;

Semantic restriction "_+_" is
[
  treapType : typed treap's type,
  xType : any's type
|
  ordType ::= treapType's ordering;
    
  Unless xType ⊆ ordType's parameters'type[1] then
  [
    Reject parse, expected:
    format "element type ⊆ “①” to be a subtype of “②”'s parameters"
    with xType, ordType
  ];

  treapType
];

/* pretty printing */
Abstract method "_show" is [treap]→string;

Method "_show" is [ t : empty treap | "" ];
Method "_show" is [ t : leaf treap | “t's value” ];
Method "_show" is [ t : leftish treap | t's left show ++ ", " ++ “t's value” ];
Method "_show" is [ t : rightish treap | “t's value” ++ ", " ++ t's right show ];
Method "_show" is 
[ 
  t : bin treap
| 
  t's left show ++ ", " ++ “t's value” ++ ", " ++ t's right show
];
     
Method "“_”" is
[
 t : treap
|
  "【" ++ t show ++ "】"
];

Method "“_”" is
[
 t : typed treap
|
  "【" ++ t's root show ++ "】"
];

Method "_treap" is 
[ 
  ord : orderingType 
| 
  a typed treap with ordering ::= ord, root ::= empty
] : typed treap;

Semantic restriction "_treap" is 
[
  ordMetaType : orderingType's type
|
  arg1Type ::= ordMetaType's parameters'type[1];
  arg2Type ::= ordMetaType's parameters'type[2];
  
  Unless arg1Type = arg2Type then
  [
    Reject parse, expected:
    format "ordering parameter types “①” and “②” have to be equal"
    with arg1Type, arg2Type
  ];
  extend typed treap with ordering : ordMetaType
] : typed treap's type;

Public method "test treap" is 
[
  t ::= [ x : [0..8], y : [0..8] | x - y ] treap;
  t2 ::= t + 1 + 3 + 5 + 0 + 8 + 4;
  t3 ::= t + 8 + 3 + 5 + 4 + 1 + 0;

  <t2,t3,t2's hash,t3's hash,t2 = t3>
];

